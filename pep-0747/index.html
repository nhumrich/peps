
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 747 – TypeExpr: Type Hint for a Type Expression | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0747/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 747 – TypeExpr: Type Hint for a Type Expression | peps.python.org'>
    <meta property="og:description" content="PEP 484 defines the notation type[C] where C is a class, to refer to a class object that is a subtype of C. It explicitly does not allow type[C] to refer to arbitrary type expression objects such as the runtime object str | None, even if C is an unbound...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0747/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="PEP 484 defines the notation type[C] where C is a class, to refer to a class object that is a subtype of C. It explicitly does not allow type[C] to refer to arbitrary type expression objects such as the runtime object str | None, even if C is an unbound...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 747</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 747 – TypeExpr: Type Hint for a Type Expression</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">David Foster &lt;david at dafoster.net&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Jelle Zijlstra &lt;jelle.zijlstra at gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-747-typeexpr-type-hint-for-a-type-expression/55984">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Topic<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="../topic/typing/">Typing</a></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">27-May-2024</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.14</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/typeform-spelling-for-a-type-annotation-object-at-runtime/51435" title="Discourse thread">19-Apr-2024</a>, <a class="reference external" href="https://discuss.python.org/t/typeform-spelling-for-a-type-annotation-object-at-runtime/51435/7/" title="Discourse message">04-May-2024</a>, <a class="reference external" href="https://discuss.python.org/t/pep-747-typeexpr-type-hint-for-a-type-expression/55984" title="Discourse thread">17-Jun-2024</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#why-cant-type-be-used">Why can’t <code class="docutils literal notranslate"><span class="pre">type[]</span></code> be used?</a></li>
<li><a class="reference internal" href="#common-kinds-of-functions-that-would-benefit-from-typeexpr">Common kinds of functions that would benefit from TypeExpr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#using-typeexprs">Using TypeExprs</a></li>
<li><a class="reference internal" href="#typeexpr-values">TypeExpr Values</a><ul>
<li><a class="reference internal" href="#explicit-typeexpr-values">Explicit TypeExpr Values</a></li>
<li><a class="reference internal" href="#implicit-typeexpr-values">Implicit TypeExpr Values</a></li>
<li><a class="reference internal" href="#literal-typeexprs">Literal[] TypeExprs</a></li>
<li><a class="reference internal" href="#static-vs-runtime-representations-of-typeexprs">Static vs. Runtime Representations of TypeExprs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#subtyping">Subtyping</a><ul>
<li><a class="reference internal" href="#relationship-with-type">Relationship with type</a></li>
<li><a class="reference internal" href="#relationship-with-uniontype">Relationship with UnionType</a></li>
<li><a class="reference internal" href="#relationship-with-object">Relationship with object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interactions-with-isinstance-and-issubclass">Interactions with isinstance() and issubclass()</a></li>
<li><a class="reference internal" href="#affected-signatures-in-the-standard-library">Affected signatures in the standard library</a><ul>
<li><a class="reference internal" href="#changed-signatures">Changed signatures</a></li>
<li><a class="reference internal" href="#unchanged-signatures">Unchanged signatures</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#advanced-examples">Advanced Examples</a><ul>
<li><a class="reference internal" href="#introspecting-typeexpr-values">Introspecting TypeExpr Values</a></li>
<li><a class="reference internal" href="#combining-with-a-type-variable">Combining with a type variable</a></li>
<li><a class="reference internal" href="#combining-with-type">Combining with type[]</a></li>
<li><a class="reference internal" href="#combining-with-typeis-and-typeguard">Combining with TypeIs[] and TypeGuard[]</a></li>
<li><a class="reference internal" href="#challenges-when-accepting-all-typeexprs">Challenges When Accepting All TypeExprs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#widen-type-c-to-support-all-type-expressions">Widen type[C] to support all type expressions</a></li>
<li><a class="reference internal" href="#accept-arbitrary-annotation-expressions">Accept arbitrary annotation expressions</a></li>
<li><a class="reference internal" href="#accept-only-universal-type-expressions">Accept only universal type expressions</a></li>
<li><a class="reference internal" href="#support-pattern-matching-on-type-expressions">Support pattern matching on type expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p><a class="pep reference internal" href="../pep-0484/" title="PEP 484 – Type Hints">PEP 484</a> defines the notation <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> where <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class, to
refer to a class object that is a subtype of <code class="docutils literal notranslate"><span class="pre">C</span></code>. It explicitly does
not allow <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> to refer to arbitrary
<a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/annotations.html#type-expression" title="(in typing)"><span class="xref std std-ref">type expression</span></a> objects such
as the runtime object <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span></code>, even if <code class="docutils literal notranslate"><span class="pre">C</span></code> is an unbounded
<code class="docutils literal notranslate"><span class="pre">TypeVar</span></code>. <a class="footnote-reference brackets" href="#type-c" id="id1">[1]</a> In cases where that restriction is unwanted, this
PEP proposes a new notation <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type, to
refer to a either a class object or some other type expression object
that is a subtype of <code class="docutils literal notranslate"><span class="pre">T</span></code>, allowing any kind of type to be referenced.</p>
<p>This PEP makes no Python grammar changes. Correct usage of
<code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> is intended to be enforced only by static and runtime
type checkers and need not be enforced by Python itself at runtime.</p>
</section>
<section id="motivation">
<span id="id2"></span><h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The introduction of <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> allows new kinds of metaprogramming
functions that operate on type expressions to be type-annotated and
understood by type checkers.</p>
<p>For example, here is a function that checks whether a value is
assignable to a variable of a particular type, and if so returns the
original value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trycast</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> and the type variable <code class="docutils literal notranslate"><span class="pre">T</span></code> enables the return
type of this function to be influenced by a <code class="docutils literal notranslate"><span class="pre">typx</span></code> value passed at
runtime, which is quite powerful.</p>
<p>Here is another function that checks whether a value is assignable to a
variable of a particular type, and if so returns <code class="docutils literal notranslate"><span class="pre">True</span></code> (as a special
<code class="docutils literal notranslate"><span class="pre">TypeIs[]</span></code> bool <a class="footnote-reference brackets" href="#typeispep" id="id3">[2]</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isassignable</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeIs</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> and <code class="docutils literal notranslate"><span class="pre">TypeIs[]</span></code> together enables type
checkers to narrow the return type appropriately depending on what type
expression is passed in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">request_json</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">if</span> <span class="n">isassignable</span><span class="p">(</span><span class="n">request_json</span><span class="p">,</span> <span class="n">MyTypedDict</span><span class="p">):</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">request_json</span><span class="p">,</span> <span class="n">MyTypedDict</span><span class="p">)</span>  <span class="c1"># type is narrowed!</span>
</pre></div>
</div>
<p>That <code class="docutils literal notranslate"><span class="pre">isassignable</span></code> function enables a kind of enhanced <code class="docutils literal notranslate"><span class="pre">isinstance</span></code>
check which is useful for <a class="reference external" href="https://mail.python.org/archives/list/typing-sig&#64;python.org/thread/I5ZOQICTJCENTCDPHLZR7NT42QJ43GP4/">checking whether a value decoded from JSON
conforms to a particular structure</a> of nested <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>s,
lists, unions, <code class="docutils literal notranslate"><span class="pre">Literal</span></code>s, and other types. This kind
of check was alluded to in <a class="pep reference internal" href="../pep-0589/#using-typeddict-types" title="PEP 589 – TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys § Using TypedDict Types">PEP 589</a> but could
not be implemented at the time without a notation similar to
<code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code>.</p>
<section id="why-cant-type-be-used">
<h3><a class="toc-backref" href="#why-cant-type-be-used" role="doc-backlink">Why can’t <code class="docutils literal notranslate"><span class="pre">type[]</span></code> be used?</a></h3>
<p>One might think you could define the example functions above to take a
<code class="docutils literal notranslate"><span class="pre">type[C]</span></code> - which is syntax that already exists - rather than a
<code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>. However if you were to do that then certain type
expressions like <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span></code> - which are not class objects and
therefore not <code class="docutils literal notranslate"><span class="pre">type</span></code>s at runtime - would be rejected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># NOTE: Uses a type[C] parameter rather than a TypeExpr[T]</span>
<span class="k">def</span> <span class="nf">trycast_type</span><span class="p">[</span><span class="n">C</span><span class="p">](</span><span class="n">typ</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">C</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<span class="n">trycast_type</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;hi&#39;</span><span class="p">)</span>  <span class="c1"># ok; str is a type</span>
<span class="n">trycast_type</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="s1">&#39;hi&#39;</span><span class="p">)</span>  <span class="c1"># ERROR; Optional[str] is not a type</span>
<span class="n">trycast_type</span><span class="p">(</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;hi&#39;</span><span class="p">)</span>  <span class="c1"># ERROR; (str | int) is not a type</span>
<span class="n">trycast_type</span><span class="p">(</span><span class="n">MyTypedDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;hi&#39;</span><span class="p">))</span>  <span class="c1"># questionable; accepted by mypy 1.9.0</span>
</pre></div>
</div>
<p>To solve that problem, <code class="docutils literal notranslate"><span class="pre">type[]</span></code> could be widened to include the
additional values allowed by <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>. However doing so would lose
<code class="docutils literal notranslate"><span class="pre">type[]</span></code>’s current ability to spell a class object which always
supports instantiation and <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks, unlike arbitrary type
expression objects. Therefore <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> is proposed as new notation
instead.</p>
<p>For a longer explanation of why we don’t just widen <code class="docutils literal notranslate"><span class="pre">type[T]</span></code> to
accept all type expressions, see
<a class="reference internal" href="#widen-type-c-to-support-all-type-expressions"><span class="std std-ref">Widen type[C] to support all type expressions</span></a>.</p>
</section>
<section id="common-kinds-of-functions-that-would-benefit-from-typeexpr">
<span id="runtime-type-checkers-using-typeexpr"></span><h3><a class="toc-backref" href="#common-kinds-of-functions-that-would-benefit-from-typeexpr" role="doc-backlink">Common kinds of functions that would benefit from TypeExpr</a></h3>
<p><a class="reference external" href="https://github.com/python/mypy/issues/9773#issuecomment-2017998886">A survey of various Python libraries</a> revealed a few kinds of commonly
defined functions which would benefit from <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code>:</p>
<ul class="simple">
<li>Assignability checkers:<ul>
<li>Returns whether a value is assignable to a type expression. If so
then also narrows the type of the value to match the type
expression.</li>
<li>Pattern 1:
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">isassignable[T](value:</span> <span class="pre">object,</span> <span class="pre">typx:</span> <span class="pre">TypeExpr[T])</span> <span class="pre">-&gt;</span> <span class="pre">TypeIs[T]</span></code></li>
<li>Pattern 2:
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">ismatch[T](value:</span> <span class="pre">object,</span> <span class="pre">typx:</span> <span class="pre">TypeExpr[T])</span> <span class="pre">-&gt;</span> <span class="pre">TypeGuard[T]</span></code></li>
<li>Examples: beartype.<a class="reference external" href="https://github.com/beartype/beartype/issues/255">is_bearable</a>, trycast.<a class="reference external" href="https://github.com/davidfstr/trycast?tab=readme-ov-file#isassignable-api">isassignable</a>,
typeguard.<a class="reference external" href="https://typeguard.readthedocs.io/en/latest/api.html#typeguard.check_type">check_type</a>, xdsl.<a class="reference external" href="https://github.com/xdslproject/xdsl/blob/ac12c9ab0d64618475efb98d1d197bdd79f593c3/xdsl/utils/hints.py#L23">isa</a></li>
</ul>
</li>
</ul>
<ul>
<li>Converters:<ul>
<li>If a value is assignable to (or coercible to) a type expression,
a <em>converter</em> returns the value narrowed to (or coerced to) that type
expression. Otherwise, it raises an exception.</li>
<li>Pattern 1:
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">convert[T](value:</span> <span class="pre">object,</span> <span class="pre">typx:</span> <span class="pre">TypeExpr[T])</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code><ul class="simple">
<li>Examples: cattrs.BaseConverter.<a class="reference external" href="https://github.com/python-attrs/cattrs/blob/5f5c11627a7f67a23d6212bc7df9f96243c62dc5/src/cattrs/converters.py#L332-L334">structure</a>, trycast.<a class="reference external" href="https://github.com/davidfstr/trycast#checkcast-api">checkcast</a>,
typedload.<a class="reference external" href="https://ltworf.github.io/typedload/">load</a></li>
</ul>
</li>
<li>Pattern 2:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Converter</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li>Examples: pydantic.<a class="reference external" href="https://stackoverflow.com/a/61021183/604063">TypeAdapter(T).validate_python</a>,
mashumaro.<a class="reference external" href="https://github.com/Fatal1ty/mashumaro?tab=readme-ov-file#usage-example">JSONDecoder(T).decode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Typed field definitions:<ul>
<li>Pattern:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Field</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="n">value_type</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li>Examples: attrs.<a class="reference external" href="https://www.attrs.org/en/stable/api.html#attrs.make_class">make_class</a>,
dataclasses.<a class="reference external" href="https://github.com/python/typeshed/issues/11653">make_dataclass</a> <a class="footnote-reference brackets" href="#dataclassinitvar" id="id4">[3]</a>, <a class="reference external" href="https://github.com/Fatal1ty/openapify/blob/c8d968c7c9c8fd7d4888bd2ddbe18ffd1469f3ca/openapify/core/models.py#L16">openapify</a></li>
</ul>
</li>
</ul>
<p>The survey also identified some introspection functions that take
annotation expressions as input using plain <code class="docutils literal notranslate"><span class="pre">object</span></code>s which would
<em>not</em> gain functionality by marking those inputs as <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code>:</p>
<ul class="simple">
<li>General introspection operations:<ul>
<li>Pattern: <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">get_annotation_info(maybe_annx:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></code></li>
<li>Examples: typing.{<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.get_origin">get_origin</a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.get_args">get_args</a>},
<a class="reference external" href="https://github.com/ilevkivskyi/typing_inspect?tab=readme-ov-file#readme">typing_inspect</a>.{is_*_type, get_origin, get_parameters}</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Before this PEP existed there were already a few definitions in use to describe
different kinds of type annotations:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------+
| +------------------------------+ |
| | +-------------------------+  | |
| | | +---------------------+ |  | |
| | | | Class object        | |  | | = type[C]
| | | +---------------------+ |  | |
| | | Type expression object  |  | | = TypeExpr[T]  &lt;-- new!
| | +-------------------------+  | |
| | Annotation expression object | |
| +------------------------------+ |
| Object                           | = object
+----------------------------------+
</pre></div>
</div>
<ul class="simple">
<li><a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/special-types.html#type-brackets" title="(in typing)"><span class="xref std std-ref">Class objects</span></a>,
spelled as <code class="docutils literal notranslate"><span class="pre">type[C]</span></code>, support <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks and are callable.<ul>
<li>Examples: <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code></li>
</ul>
</li>
<li><a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/annotations.html#type-expression" title="(in typing)"><span class="xref std std-ref">Type expressions</span></a>
include any type annotation which describes a type.<ul>
<li>Examples: <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">MyTypedDict</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>,
<code class="docutils literal notranslate"><span class="pre">Literal['square']</span></code>, any class object</li>
</ul>
</li>
<li><a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/annotations.html#annotation-expression" title="(in typing)"><span class="xref std std-ref">Annotation expressions</span></a>
include any type annotation, including those only valid in specific contexts.<ul>
<li>Examples: <code class="docutils literal notranslate"><span class="pre">Final[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">Required[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">ClassVar[str]</span></code>,
any type expression</li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> aligns with an existing definition from the above list -
<em>type expression</em> - to avoid introducing yet another subset of type annotations
that users of Python typing need to think about.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> aligns with <em>type expression</em> specifically
because a type expression is already used to parameterize type variables,
which are used in combination with <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> and <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> to enable
the compelling examples mentioned in <a class="reference internal" href="#motivation"><span class="std std-ref">Motivation</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> does not align with <em>annotation expression</em> for reasons given in
<a class="reference internal" href="#accept-arbitrary-annotation-expressions"><span class="std std-ref">Rejected Ideas » Accept arbitrary annotation expressions</span></a>.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> value represents a <a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/annotations.html#type-expression" title="(in typing)"><span class="xref std std-ref">type expression</span></a>
such as <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">int]</span></code>, or <code class="docutils literal notranslate"><span class="pre">MyTypedDict</span></code>.
A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> type is written as
<code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type or a type variable. It can also be
written without brackets as just <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>, which is treated the same as
to <code class="docutils literal notranslate"><span class="pre">TypeExpr[Any]</span></code>.</p>
<section id="using-typeexprs">
<h3><a class="toc-backref" href="#using-typeexprs" role="doc-backlink">Using TypeExprs</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> is a new kind of type expression, usable in any context where a
type expression is valid, as a function parameter type, a return type,
or a variable type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_union_type</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="o">...</span>  <span class="c1"># parameter type</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">union_of</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">](</span><span class="n">s</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">t</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> \
    <span class="o">-&gt;</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span> <span class="o">|</span> <span class="n">T</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># return type</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="nb">str</span>  <span class="c1"># variable type</span>
</pre></div>
</div>
<p>Note however that an <em>unannotated</em> variable assigned a type expression literal
will not be inferred to be of <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> type by type checkers because PEP
484 <a class="pep reference internal" href="../pep-0484/#type-aliases" title="PEP 484 – Type Hints § Type aliases">reserves that syntax for defining type aliases</a>:</p>
<ul>
<li>No:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR_TYPE</span> <span class="o">=</span> <span class="nb">str</span>  <span class="c1"># OOPS; treated as a type alias!</span>
</pre></div>
</div>
</li>
</ul>
<p>If you want a type checker to recognize a type expression literal in a bare
assignment you’ll need to explicitly declare the assignment-target as
having <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> type:</p>
<ul>
<li>Yes:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li>Yes:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span>
<span class="n">STR_TYPE</span> <span class="o">=</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li>Okay, but discouraged:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STR_TYPE</span> <span class="o">=</span> <span class="nb">str</span>  <span class="c1"># type: TypeExpr  # the type comment is significant</span>
</pre></div>
</div>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> values can be passed around and assigned just like normal
values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">swap1</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">](</span><span class="n">t1</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">t2</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">]]:</span>
    <span class="n">t1_new</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2</span>  <span class="c1"># assigns a TypeExpr value to a new annotated variable</span>
    <span class="n">t2_new</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1_new</span><span class="p">,</span> <span class="n">t2_new</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">swap2</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">](</span><span class="n">t1</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">t2</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">]]:</span>
    <span class="n">t1_new</span> <span class="o">=</span> <span class="n">t2</span>  <span class="c1"># assigns a TypeExpr value to a new unannotated variable</span>
    <span class="n">t2_new</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">t1_new</span><span class="p">,</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">t2_new</span><span class="p">,</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">S</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1_new</span><span class="p">,</span> <span class="n">t2_new</span><span class="p">)</span>

<span class="c1"># NOTE: A more straightforward implementation would use isinstance()</span>
<span class="k">def</span> <span class="nf">ensure_int</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">value_type</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># assigns a type (a subtype of TypeExpr)</span>
    <span class="k">assert</span> <span class="n">value_type</span> <span class="o">==</span> <span class="nb">int</span>
</pre></div>
</div>
</section>
<section id="typeexpr-values">
<h3><a class="toc-backref" href="#typeexpr-values" role="doc-backlink">TypeExpr Values</a></h3>
<p>A variable of type <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type, can hold any
<strong>type expression object</strong> - the result of evaluating a
<a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/annotations.html#type-expression" title="(in typing)"><span class="xref std std-ref">type expression</span></a>
at runtime - which is a subtype of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>Incomplete expressions like a bare <code class="docutils literal notranslate"><span class="pre">Optional</span></code> or <code class="docutils literal notranslate"><span class="pre">Union</span></code> which do
not spell a type are not <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> values.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[...]</span></code> is itself a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPTIONAL_INT_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># OK</span>
<span class="k">assert</span> <span class="n">isassignable</span><span class="p">(</span><span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">OPTIONAL_INT_TYPE</span><span class="p">)</span>
</pre></div>
</div>
<p id="non-universal-typeexpr"><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> values include <em>all</em> type expressions including some
<strong>non-universal type expressions</strong> which are not valid in all annotation contexts.
In particular:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Self</span></code> (valid only in some contexts)</li>
<li><code class="docutils literal notranslate"><span class="pre">TypeGuard[...]</span></code> (valid only in some contexts)</li>
<li><code class="docutils literal notranslate"><span class="pre">TypeIs[...]</span></code> (valid only in some contexts)</li>
</ul>
<section id="explicit-typeexpr-values">
<h4><a class="toc-backref" href="#explicit-typeexpr-values" role="doc-backlink">Explicit TypeExpr Values</a></h4>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">TypeExpr(T)</span></code> (with parentheses) can be used to
spell a <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> value explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NONE</span> <span class="o">=</span> <span class="n">TypeExpr</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">INT1</span> <span class="o">=</span> <span class="n">TypeExpr</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>  <span class="c1"># stringified type expression</span>
<span class="n">INT2</span> <span class="o">=</span> <span class="n">TypeExpr</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>At runtime the <code class="docutils literal notranslate"><span class="pre">TypeExpr(...)</span></code> callable returns its single argument unchanged.</p>
</section>
<section id="implicit-typeexpr-values">
<span id="id5"></span><h4><a class="toc-backref" href="#implicit-typeexpr-values" role="doc-backlink">Implicit TypeExpr Values</a></h4>
<p>Historically static type checkers have only needed to recognize
<em>type expressions</em> in contexts where a type expression was expected.
Now <em>type expression objects</em> must also be recognized in contexts where a
value expression is expected.</p>
<p>Static type checkers already recognize <strong>class objects</strong> (<code class="docutils literal notranslate"><span class="pre">type[C]</span></code>):</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">C</span></code> has type <code class="docutils literal notranslate"><span class="pre">type[C]</span></code>,
for each of the following values of C:<ul>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> (where <code class="docutils literal notranslate"><span class="pre">name</span></code> must refer to a valid in-scope class, type alias, or TypeVar)</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
</ul>
</li>
</ul>
<p>The following <strong>unparameterized type expressions</strong> can be recognized unambiguously:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">X</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[X]</span></code>,
for each of the following values of X:<ul>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Any&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Self&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;LiteralString&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;NoReturn&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Never&gt;</span></code></li>
</ul>
</li>
</ul>
<p><strong>None</strong>: The type expression <code class="docutils literal notranslate"><span class="pre">None</span></code> (<code class="docutils literal notranslate"><span class="pre">NoneType</span></code>) is ambiguous with the value <code class="docutils literal notranslate"><span class="pre">None</span></code>,
so must use the explicit <code class="docutils literal notranslate"><span class="pre">TypeExpr(...)</span></code> syntax:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">TypeExpr(None)</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[None]</span></code>.</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">None</span></code> continues to have type <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
</ul>
<p>The following <strong>parameterized type expressions</strong> can be recognized unambiguously:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">X</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[X]</span></code>,
for each of the following values of X:<ul>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Literal&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Optional&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Union&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;Callable&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;tuple&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;TypeGuard&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;TypeIs&gt;</span> <span class="pre">'['</span> <span class="pre">...</span> <span class="pre">']'</span></code></li>
</ul>
</li>
</ul>
<p id="recognizing-annotated"><strong>Annotated</strong>: The type expression <code class="docutils literal notranslate"><span class="pre">Annotated[...]</span></code> is ambiguous with
the annotation expression <code class="docutils literal notranslate"><span class="pre">Annotated[...]</span></code>,
so must be disambiguated based on its argument type:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">Annotated[x,</span> <span class="pre">...]</span></code> has type <code class="docutils literal notranslate"><span class="pre">type[C]</span></code>
if <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">type[C]</span></code>.</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">Annotated[x,</span> <span class="pre">...]</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>
if <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>.</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">Annotated[x,</span> <span class="pre">...]</span></code> has type <code class="docutils literal notranslate"><span class="pre">object</span></code>
if <code class="docutils literal notranslate"><span class="pre">x</span></code> has a type that is not <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> or <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>.</li>
</ul>
<p><strong>Union</strong>: The type expression <code class="docutils literal notranslate"><span class="pre">T1</span> <span class="pre">|</span> <span class="pre">T2</span></code> is ambiguous with
the value <code class="docutils literal notranslate"><span class="pre">int1</span> <span class="pre">|</span> <span class="pre">int2</span></code>, <code class="docutils literal notranslate"><span class="pre">set1</span> <span class="pre">|</span> <span class="pre">set2</span></code>, <code class="docutils literal notranslate"><span class="pre">dict1</span> <span class="pre">|</span> <span class="pre">dict2</span></code>, and more,
so must be disambiguated based on its argument types:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code> has type equal to the return type of <code class="docutils literal notranslate"><span class="pre">type(x).__or__</span></code>
if <code class="docutils literal notranslate"><span class="pre">type(x)</span></code> overrides the <code class="docutils literal notranslate"><span class="pre">__or__</span></code> method.<ul>
<li>When <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">builtins.type</span></code>, <code class="docutils literal notranslate"><span class="pre">types.GenericAlias</span></code>, or the
internal type of a typing special form, <code class="docutils literal notranslate"><span class="pre">type(x).__or__</span></code> has a return type
in the format <code class="docutils literal notranslate"><span class="pre">TypeExpr[T1</span> <span class="pre">|</span> <span class="pre">T2]</span></code>.</li>
</ul>
</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code> has type equal to the return type of <code class="docutils literal notranslate"><span class="pre">type(y).__ror__</span></code>
if <code class="docutils literal notranslate"><span class="pre">type(y)</span></code> overrides the <code class="docutils literal notranslate"><span class="pre">__ror__</span></code> method.<ul>
<li>When <code class="docutils literal notranslate"><span class="pre">y</span></code> has type <code class="docutils literal notranslate"><span class="pre">builtins.type</span></code>, <code class="docutils literal notranslate"><span class="pre">types.GenericAlias</span></code>, or the
internal type of a typing special form, <code class="docutils literal notranslate"><span class="pre">type(y).__ror__</span></code> has a return type
in the format <code class="docutils literal notranslate"><span class="pre">TypeExpr[T1</span> <span class="pre">|</span> <span class="pre">T2]</span></code>.</li>
</ul>
</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code> has type <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>
in all other situations.<ul>
<li>This rule is intended to be consistent with the preexisting fallback rule
used by static type checkers.</li>
</ul>
</li>
</ul>
<p>The <strong>stringified type expression</strong> <code class="docutils literal notranslate"><span class="pre">&quot;T&quot;</span></code> is ambiguous with both
the stringified annotation expression <code class="docutils literal notranslate"><span class="pre">&quot;T&quot;</span></code>
and the string literal <code class="docutils literal notranslate"><span class="pre">&quot;T&quot;</span></code>,
so must use the explicit <code class="docutils literal notranslate"><span class="pre">TypeExpr(...)</span></code> syntax:</p>
<ul class="simple">
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">TypeExpr(&quot;T&quot;)</span></code> has type <code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a valid type expression</li>
<li>As a value expression, <code class="docutils literal notranslate"><span class="pre">&quot;T&quot;</span></code> continues to have type <code class="docutils literal notranslate"><span class="pre">Literal[&quot;T&quot;]</span></code>.</li>
</ul>
<p>No other kinds of type expressions currently exist.</p>
<p>New kinds of type expressions that are introduced should define how they
will be recognized in a value expression context.</p>
</section>
<section id="literal-typeexprs">
<h4><a class="toc-backref" href="#literal-typeexprs" role="doc-backlink">Literal[] TypeExprs</a></h4>
<p>A value of <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> type is <em>not</em> considered assignable to
a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> variable even if all of its members spell valid types because
dynamic values are not allowed in type expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STRS_TYPE_NAME</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;str&#39;</span><span class="p">,</span> <span class="s1">&#39;list[str]&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;str&#39;</span>
<span class="n">STRS_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="n">STRS_TYPE_NAME</span>  <span class="c1"># ERROR: Literal[] value is not a TypeExpr</span>
</pre></div>
</div>
<p>However <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> itself is still a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DIRECTION_TYPE</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]</span>  <span class="c1"># OK</span>
</pre></div>
</div>
</section>
<section id="static-vs-runtime-representations-of-typeexprs">
<h4><a class="toc-backref" href="#static-vs-runtime-representations-of-typeexprs" role="doc-backlink">Static vs. Runtime Representations of TypeExprs</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> value appearing statically in a source file may be normalized
to a different representation at runtime. For example string-based
forward references are normalized at runtime to be <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> instances
in some contexts: <a class="footnote-reference brackets" href="#forward-ref-normalization" id="id6">[4]</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntTree</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;IntTree&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IntTree</span>
<span class="go">list[typing.Union[int, ForwardRef(&#39;IntTree&#39;)]]</span>
</pre></div>
</div>
<p>The runtime representations of <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>s are considered implementation
details that may change over time and therefore static type checkers are
not required to recognize them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INT_TREE</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;IntTree&#39;</span><span class="p">)</span>  <span class="c1"># ERROR: Runtime-only form</span>
</pre></div>
</div>
<p>Runtime type checkers that wish to assign a runtime-only representation
of a type expression to a <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> variable must use <code class="docutils literal notranslate"><span class="pre">cast()</span></code> to
avoid errors from static type checkers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INT_TREE</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeExpr</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;IntTree&#39;</span><span class="p">))</span>  <span class="c1"># OK</span>
</pre></div>
</div>
</section>
</section>
<section id="subtyping">
<h3><a class="toc-backref" href="#subtyping" role="doc-backlink">Subtyping</a></h3>
<p>Whether a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> value can be assigned from one variable to another is
determined by the following rules:</p>
<section id="relationship-with-type">
<h4><a class="toc-backref" href="#relationship-with-type" role="doc-backlink">Relationship with type</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> is covariant in its argument type, just like <code class="docutils literal notranslate"><span class="pre">type[]</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TypeExpr[T1]</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">TypeExpr[T2]</span></code> iff <code class="docutils literal notranslate"><span class="pre">T1</span></code> is a
subtype of <code class="docutils literal notranslate"><span class="pre">T2</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">type[C1]</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">TypeExpr[C2]</span></code> iff <code class="docutils literal notranslate"><span class="pre">C1</span></code> is a subtype
of <code class="docutils literal notranslate"><span class="pre">C2</span></code>.</li>
</ul>
<p>An unparameterized <code class="docutils literal notranslate"><span class="pre">type</span></code> can be assigned to an unparameterized <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>
but not the other way around:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">type[Any]</span></code> is assignable to <code class="docutils literal notranslate"><span class="pre">TypeExpr[Any]</span></code>. (But not the
other way around.)</li>
</ul>
</section>
<section id="relationship-with-uniontype">
<h4><a class="toc-backref" href="#relationship-with-uniontype" role="doc-backlink">Relationship with UnionType</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[U]</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> iff <code class="docutils literal notranslate"><span class="pre">U</span></code> is
the type expression <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span> <span class="pre">|</span> <span class="pre">...</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TypeExpr[X</span> <span class="pre">|</span> <span class="pre">Y</span> <span class="pre">|</span> <span class="pre">...]</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">UnionType</span></code> is assignable to <code class="docutils literal notranslate"><span class="pre">TypeExpr[Any]</span></code>.</p>
</section>
<section id="relationship-with-object">
<h4><a class="toc-backref" href="#relationship-with-object" role="doc-backlink">Relationship with object</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> is a kind of <code class="docutils literal notranslate"><span class="pre">object</span></code>, just like <code class="docutils literal notranslate"><span class="pre">type[]</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> for any <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">object</span></code>.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type variable, is assumed to have all
the attributes and methods of <code class="docutils literal notranslate"><span class="pre">object</span></code> and is not callable.</p>
</section>
</section>
<section id="interactions-with-isinstance-and-issubclass">
<h3><a class="toc-backref" href="#interactions-with-isinstance-and-issubclass" role="doc-backlink">Interactions with isinstance() and issubclass()</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> special form cannot be used as the <code class="docutils literal notranslate"><span class="pre">type</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">isinstance</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">TypeExpr</span><span class="p">)</span>
<span class="go">TypeError: typing.TypeExpr cannot be used with isinstance()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span>
<span class="go">TypeError: isinstance() argument 2 cannot be a parameterized generic</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> special form cannot be used as any argument to
<code class="docutils literal notranslate"><span class="pre">issubclass</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">TypeExpr</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="go">TypeError: issubclass() arg 1 must be a class</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">TypeExpr</span><span class="p">)</span>
<span class="go">TypeError: typing.TypeExpr cannot be used with issubclass()</span>
</pre></div>
</div>
</section>
<section id="affected-signatures-in-the-standard-library">
<h3><a class="toc-backref" href="#affected-signatures-in-the-standard-library" role="doc-backlink">Affected signatures in the standard library</a></h3>
<section id="changed-signatures">
<h4><a class="toc-backref" href="#changed-signatures" role="doc-backlink">Changed signatures</a></h4>
<p>The following signatures related to type expressions introduce
<code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> where previously <code class="docutils literal notranslate"><span class="pre">object</span></code> or <code class="docutils literal notranslate"><span class="pre">Any</span></code> existed:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">typing.cast</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">typing.assert_type</span></code></li>
</ul>
<p>The following signatures transforming union type expressions introduce
<code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> where previously <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> existed so that a more-precise
<code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> type can be inferred:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">builtins.type[T].__or__</span></code><ul>
<li>Old: <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">__or__(self,</span> <span class="pre">value:</span> <span class="pre">Any,</span> <span class="pre">/)</span> <span class="pre">-&gt;</span> <span class="pre">types.UnionType:</span> <span class="pre">...</span></code></li>
<li>New: <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">__or__[T2](self,</span> <span class="pre">value:</span> <span class="pre">TypeExpr[T2],</span> <span class="pre">/)</span> <span class="pre">-&gt;</span> <span class="pre">TypeExpr[T</span> <span class="pre">|</span> <span class="pre">T2]:</span> <span class="pre">...</span></code></li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">builtins.type[T].__ror__</span></code><ul>
<li>Old: <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">__ror__(self,</span> <span class="pre">value:</span> <span class="pre">Any,</span> <span class="pre">/)</span> <span class="pre">-&gt;</span> <span class="pre">types.UnionType:</span> <span class="pre">...</span></code></li>
<li>New: <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">__ror__[T1](self,</span> <span class="pre">value:</span> <span class="pre">TypeExpr[T1],</span> <span class="pre">/)</span> <span class="pre">-&gt;</span> <span class="pre">TypeExpr[T1</span> <span class="pre">|</span> <span class="pre">T]:</span> <span class="pre">...</span></code></li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">types.GenericAlias.{__or__,__ror__}</span></code></li>
<li>«the internal type of a typing special form»<code class="docutils literal notranslate"><span class="pre">.{__or__,__ror__}</span></code></li>
</ul>
<p>However the implementations of those methods continue to return <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>
instances at runtime so that runtime <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks like
<code class="docutils literal notranslate"><span class="pre">isinstance('42',</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">str)</span></code> and <code class="docutils literal notranslate"><span class="pre">isinstance(int</span> <span class="pre">|</span> <span class="pre">str,</span> <span class="pre">UnionType)</span></code>
continue to work.</p>
</section>
<section id="unchanged-signatures">
<h4><a class="toc-backref" href="#unchanged-signatures" role="doc-backlink">Unchanged signatures</a></h4>
<p>The following signatures related to annotation expressions continue to
use <code class="docutils literal notranslate"><span class="pre">object</span></code> and remain unchanged:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">typing.get_origin</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">typing.get_args</span></code></li>
</ul>
<p>The following signatures related to class objects continue to use
<code class="docutils literal notranslate"><span class="pre">type</span></code> and remain unchanged:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">builtins.isinstance</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">builtins.issubclass</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">builtins.type</span></code></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">typing.get_type_hints(...,</span> <span class="pre">include_extras=False)</span></code> nearly returns only type
expressions in Python 3.12, stripping out most type qualifiers
(<code class="docutils literal notranslate"><span class="pre">Required,</span> <span class="pre">NotRequired,</span> <span class="pre">ReadOnly,</span> <span class="pre">Annotated</span></code>) but currently preserves a
few type qualifiers which are only allowed in annotation expressions
(<code class="docutils literal notranslate"><span class="pre">ClassVar,</span> <span class="pre">Final,</span> <span class="pre">InitVar,</span> <span class="pre">Unpack</span></code>). It may be desirable to alter the
behavior of this function in the future to also strip out those
qualifiers and actually return type expressions, although this PEP does
not propose those changes now:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">typing.get_type_hints(...,</span> <span class="pre">include_extras=False)</span></code><ul>
<li>Almost returns only type expressions, but not quite</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">typing.get_type_hints(...,</span> <span class="pre">include_extras=True)</span></code><ul>
<li>Returns annotation expressions</li>
</ul>
</li>
</ul>
<p>The following signatures accepting union type expressions continue
to use <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">builtins.isinstance</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">builtins.issubclass</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">typing.get_origin</span></code> (used in an <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>)</li>
</ul>
<p>The following signatures transforming union type expressions continue
to use <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> because it is not possible to infer a more-precise
<code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> type:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">types.UnionType.{__or__,__ror__}</span></code></li>
</ul>
</section>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>As a value expression, <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> previously had type <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> (via <a class="pep reference internal" href="../pep-0604/" title="PEP 604 – Allow writing union types as X | Y">PEP 604</a>)
but this PEP gives it the more-precise static type <code class="docutils literal notranslate"><span class="pre">TypeExpr[X</span> <span class="pre">|</span> <span class="pre">Y]</span></code>
(a subtype of <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>) while continuing to return a <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> instance at runtime.
Preserving compability with <code class="docutils literal notranslate"><span class="pre">UnionType</span></code> is important because <code class="docutils literal notranslate"><span class="pre">UnionType</span></code>
supports <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks, unlike <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>, and existing code relies
on being able to perform those checks.</p>
<p>The rules for recognizing other kinds of type expression objects
in a value expression context were not previously defined, so static type checkers
<a class="reference external" href="https://discuss.python.org/t/typeform-spelling-for-a-type-annotation-object-at-runtime/51435/34">varied in what types were assigned</a>
to such objects. Existing programs manipulating type expression objects
were already limited in manipulating them as plain <code class="docutils literal notranslate"><span class="pre">object</span></code> values,
and such programs should not break with
<a class="reference internal" href="#implicit-typeexpr-values"><span class="std std-ref">the newly-defined rules</span></a>.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Normally when using type annotations in Python you’re concerned with defining
the shape of values allowed to be passed to a function parameter, returned
by a function, or stored in a variable:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              parameter type   return type
              |                |
              v                v
def plus(n1: int, n2: int) -&gt; int:
    sum: int = n1 + n2
          ^
          |
          variable type

    return sum
</pre></div>
</div>
<p>However type annotations themselves are valid values in Python and can be
assigned to variables and manipulated like any other data in a program:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> a variable                    a type
 |                             |
 v                             v
MAYBE_INT_TYPE: TypeExpr = int | None
                 ^
                 |
                 the type of a type
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> is how you spell the type of a variable containing a
type annotation object describing a type.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">type[]</span></code>, but <code class="docutils literal notranslate"><span class="pre">type[]</span></code> can only
spell simple <strong>class objects</strong> like <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, or <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>.
<code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> by contrast can additionally spell more complex types,
including those with brackets (like <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>) or pipes (like <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span></code>),
and including special types like <code class="docutils literal notranslate"><span class="pre">Any</span></code>, <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>, or <code class="docutils literal notranslate"><span class="pre">Never</span></code>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> variable looks similar to a <code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> definition, but
can only be used where a dynamic value is expected.
<code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> (and the <code class="docutils literal notranslate"><span class="pre">type</span></code> statement) by contrast define a name that can
be used where a fixed type is expected:</p>
<ul>
<li>Okay, but discouraged in Python 3.12+:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MaybeFloat</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaybeFloat</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li>Yes:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MaybeFloat</span> <span class="o">=</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaybeFloat</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li>No:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">maybe_float</span><span class="p">:</span> <span class="n">TypeExpr</span> <span class="o">=</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">maybe_float</span><span class="p">:</span> <span class="o">...</span>  <span class="c1"># ERROR: Can&#39;t use TypeExpr value in a type annotation</span>
</pre></div>
</div>
</li>
</ul>
<p>It is uncommon for a programmer to define their <em>own</em> function which accepts
a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> parameter or returns a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> value. Instead it is more common
for a programmer to pass a literal type expression to an <em>existing</em> function
accepting a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> input which was imported from a runtime type checker
library.</p>
<p>For example the <code class="docutils literal notranslate"><span class="pre">isassignable</span></code> function from the <code class="docutils literal notranslate"><span class="pre">trycast</span></code> library
can be used like Python’s built-in <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> function to check whether
a value matches the shape of a particular type.
<code class="docutils literal notranslate"><span class="pre">isassignable</span></code> will accept <em>any</em> kind of type as an input because its input
is a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>. By contrast <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> only accepts a simple class object
(a <code class="docutils literal notranslate"><span class="pre">type[]</span></code>) as input:</p>
<ul>
<li>Yes:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">trycast</span> <span class="kn">import</span> <span class="n">isassignable</span>

<span class="k">if</span> <span class="n">isassignable</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="n">MyTypedDict</span><span class="p">):</span>  <span class="c1"># OK: MyTypedDict is a TypeExpr[]</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
<li>No:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="n">MyTypedDict</span><span class="p">):</span>  <span class="c1"># ERROR: MyTypedDict is not a type[]</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<p>There are <a class="reference internal" href="#runtime-type-checkers-using-typeexpr"><span class="std std-ref">many other runtime type checkers</span></a>
providing useful functions that accept a <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>.</p>
</section>
<section id="advanced-examples">
<span id="id7"></span><h2><a class="toc-backref" href="#advanced-examples" role="doc-backlink">Advanced Examples</a></h2>
<p>If you want to write your own runtime type checker or some other
kind of function that manipulates types as values at runtime,
this section gives examples of how you might implement such a function
using <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>.</p>
<section id="introspecting-typeexpr-values">
<h3><a class="toc-backref" href="#introspecting-typeexpr-values" role="doc-backlink">Introspecting TypeExpr Values</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> is very similar to an <code class="docutils literal notranslate"><span class="pre">object</span></code> at runtime, with no additional
attributes or methods defined.</p>
<p>You can use existing introspection functions like <code class="docutils literal notranslate"><span class="pre">typing.get_origin</span></code> and
<code class="docutils literal notranslate"><span class="pre">typing.get_args</span></code> to extract the components of a type expression that looks
like <code class="docutils literal notranslate"><span class="pre">Origin[Arg1,</span> <span class="pre">Arg2,</span> <span class="pre">...,</span> <span class="pre">ArgN]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>

<span class="k">def</span> <span class="nf">strip_annotated_metadata</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_origin</span><span class="p">(</span><span class="n">typx</span><span class="p">)</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">Annotated</span><span class="p">:</span>
        <span class="n">typx</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_args</span><span class="p">(</span><span class="n">typx</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">typx</span>
</pre></div>
</div>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> and <code class="docutils literal notranslate"><span class="pre">is</span></code> to distinguish one kind of
type expression from another:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">typing</span>

<span class="k">def</span> <span class="nf">split_union</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">TypeExpr</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">typx</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>  <span class="c1"># X | Y</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">tuple</span><span class="p">[</span><span class="n">TypeExpr</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_args</span><span class="p">(</span><span class="n">typx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_origin</span><span class="p">(</span><span class="n">typx</span><span class="p">)</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">:</span>  <span class="c1"># Union[X, Y]</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">tuple</span><span class="p">[</span><span class="n">TypeExpr</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_args</span><span class="p">(</span><span class="n">typx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">typx</span> <span class="ow">in</span> <span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Never</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">NoReturn</span><span class="p">,):</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">typx</span><span class="p">,)</span>
</pre></div>
</div>
</section>
<section id="combining-with-a-type-variable">
<h3><a class="toc-backref" href="#combining-with-a-type-variable" role="doc-backlink">Combining with a type variable</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> can be parameterized by a type variable that is used elsewhere within
the same function definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">as_instance</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">typx</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">typx</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="combining-with-type">
<h3><a class="toc-backref" href="#combining-with-type" role="doc-backlink">Combining with type[]</a></h3>
<p>Both <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> and <code class="docutils literal notranslate"><span class="pre">type[]</span></code> can be parameterized by the same type
variable within the same function definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">as_type</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">typx</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">typx</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="combining-with-typeis-and-typeguard">
<h3><a class="toc-backref" href="#combining-with-typeis-and-typeguard" role="doc-backlink">Combining with TypeIs[] and TypeGuard[]</a></h3>
<p>A type variable parameterizing a <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> can also be used by a <code class="docutils literal notranslate"><span class="pre">TypeIs[]</span></code>
within the same function definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isassignable</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeIs</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span> <span class="o">...</span>

<span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">if</span> <span class="n">isassignable</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>or by a <code class="docutils literal notranslate"><span class="pre">TypeGuard[]</span></code> within the same function definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isdefault</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">typx</span><span class="p">())</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">typx</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>

<span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">if</span> <span class="n">isdefault</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">value</span>
<span class="k">elif</span> <span class="n">isdefault</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s1">&#39;&#39;</span> <span class="o">==</span> <span class="n">value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="challenges-when-accepting-all-typeexprs">
<h3><a class="toc-backref" href="#challenges-when-accepting-all-typeexprs" role="doc-backlink">Challenges When Accepting All TypeExprs</a></h3>
<p>A function that takes an <em>arbitrary</em> <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> as
input must support a large variety of possible type expressions and is
not easy to write. Some challenges faced by such a function include:</p>
<ul class="simple">
<li>An ever-increasing number of typing special forms are introduced with
each new Python version which must be recognized, with special
handling required for each one.</li>
<li>Stringified type annotations <a class="footnote-reference brackets" href="#strann-less-common" id="id8">[5]</a> (like <code class="docutils literal notranslate"><span class="pre">'list[str]'</span></code>)
must be <em>parsed</em> (to something like <code class="docutils literal notranslate"><span class="pre">typing.List[str]</span></code>) to be introspected.<ul>
<li>In practice it is extremely difficult for stringified type
annotations to be handled reliably at runtime, so runtime type
checkers may opt to not support them at all.</li>
</ul>
</li>
<li>Resolving string-based forward references inside type
expressions to actual values must typically be done using <code class="docutils literal notranslate"><span class="pre">eval()</span></code>,
which is difficult/impossible to use in a safe way.</li>
<li>Recursive types like <code class="docutils literal notranslate"><span class="pre">IntTree</span> <span class="pre">=</span> <span class="pre">list[typing.Union[int,</span> <span class="pre">'IntTree']]</span></code>
are not possible to fully resolve.</li>
<li>Supporting user-defined generic types (like Django’s
<code class="docutils literal notranslate"><span class="pre">QuerySet[User]</span></code>) requires user-defined functions to
recognize/parse, which a runtime type checker should provide a
registration API for.</li>
</ul>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The following will be true when
<a class="reference external" href="https://github.com/python/mypy/issues/9773">mypy#9773</a> is implemented:</p>
<blockquote>
<div>The mypy type checker supports <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> types.</div></blockquote>
<p>A reference implementation of the runtime component is provided in the
<code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code> module.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="widen-type-c-to-support-all-type-expressions">
<span id="id9"></span><h3><a class="toc-backref" href="#widen-type-c-to-support-all-type-expressions" role="doc-backlink">Widen type[C] to support all type expressions</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> was <a class="reference external" href="https://mail.python.org/archives/list/typing-sig&#64;python.org/message/D5FHORQVPHX3BHUDGF3A3TBZURBXLPHD/">designed</a> to only be used to describe class objects. A
class object can always be used as the second argument of <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>
and can usually be instantiated by calling it.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> on the other hand is typically introspected by the user in
some way, is not necessarily directly instantiable, and is not
necessarily directly usable in a regular <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> check.</p>
<p>It would be possible to widen <code class="docutils literal notranslate"><span class="pre">type</span></code> to include the additional values
allowed by <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code> but it would reduce clarity about the user’s
intentions when working with a <code class="docutils literal notranslate"><span class="pre">type</span></code>. Different concepts and usage
patterns; different spellings.</p>
</section>
<section id="accept-arbitrary-annotation-expressions">
<span id="id10"></span><h3><a class="toc-backref" href="#accept-arbitrary-annotation-expressions" role="doc-backlink">Accept arbitrary annotation expressions</a></h3>
<p>Certain typing special forms can be used in <em>some</em> but not <em>all</em>
annotation contexts:</p>
<p>For example <code class="docutils literal notranslate"><span class="pre">Final[]</span></code> can be used as a variable type but not as a
parameter type or a return type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_const</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">not_reassignable</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span> <span class="o">...</span>  <span class="c1"># ERROR: Final[] not allowed here</span>

<span class="k">def</span> <span class="nf">nonsense</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Final</span><span class="p">[</span><span class="nb">object</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># ERROR: Final[] not meaningful here</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeExpr[T]</span></code> does not allow matching such annotation expressions
because it is not clear what it would mean for such an expression
to parameterized by a type variable in position <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ismatch</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">some_arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ismatch</span><span class="p">(</span><span class="n">some_arg</span><span class="p">,</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>  <span class="c1"># ERROR: Final[int] is not a TypeExpr</span>
        <span class="n">reveal_type</span><span class="p">(</span><span class="n">some_arg</span><span class="p">)</span>  <span class="c1"># ? NOT Final[int], because invalid for a parameter</span>
</pre></div>
</div>
<p>Functions that wish to operate on <em>all</em> kinds of annotation expressions,
including those that are not <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>s, can continue to accept such
inputs as <code class="docutils literal notranslate"><span class="pre">object</span></code> parameters, as they must do so today.</p>
</section>
<section id="accept-only-universal-type-expressions">
<h3><a class="toc-backref" href="#accept-only-universal-type-expressions" role="doc-backlink">Accept only universal type expressions</a></h3>
<p>Earlier drafts of this PEP only allowed <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> to match the subset
of type expressions which are valid in <em>all</em> contexts, excluding
<a class="reference internal" href="#non-universal-typeexpr"><span class="std std-ref">non-universal type expressions</span></a>.
However doing that would effectively
create a new subset of annotation expressions that Python typing users
would have to understand, on top of all the existing distinctions between
“class objects”, “type expressions”, and “annotation expressions”.</p>
<p>To avoid introducing yet another concept that everyone has to learn,
this proposal just rounds <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code> to exactly match the existing
definition of a “type expression”.</p>
</section>
<section id="support-pattern-matching-on-type-expressions">
<h3><a class="toc-backref" href="#support-pattern-matching-on-type-expressions" role="doc-backlink">Support pattern matching on type expressions</a></h3>
<p>It was asserted that some functions may wish to pattern match on the
interior of type expressions in their signatures.</p>
<p>One use case is to allow a function to explicitly enumerate all the
<em>specific</em> kinds of type expressions it supports as input.
Consider the following possible pattern matching syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">checkcast</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">AT</span><span class="o">=</span><span class="n">Annotated</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Anns</span><span class="p">]],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">checkcast</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">UT</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">checkcast</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">C</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span> <span class="o">...</span>
<span class="c1"># ... (more)</span>
</pre></div>
</div>
<p>All functions observed in the wild that conceptually take a <code class="docutils literal notranslate"><span class="pre">TypeExpr[]</span></code>
generally try to support <em>all</em> kinds of type expressions, so it doesn’t
seem valuable to enumerate a particular subset.</p>
<p>Additionally the above syntax isn’t precise enough to fully describe the
actual input constraints for a typical function in the wild. For example
many functions recognize un-stringified type expressions like
<code class="docutils literal notranslate"><span class="pre">list[Movie]</span></code> but may not recognize type expressions with stringified
subcomponents like <code class="docutils literal notranslate"><span class="pre">list['Movie']</span></code>.</p>
<p>A second use case for pattern matching on the interior of type
expressions is to explicitly match an <code class="docutils literal notranslate"><span class="pre">Annotated[]</span></code> form to pull out the
interior type argument and strip away the metadata:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">checkcast</span><span class="p">(</span>
    <span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">AT</span><span class="o">=</span><span class="n">Annotated</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Anns</span><span class="p">]],</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">object</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</pre></div>
</div>
<p>However <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">metadata]</span></code> is already treated equivalent to <code class="docutils literal notranslate"><span class="pre">T</span></code> anyway.
There’s no additional value in being explicit about this behavior.
The example above could be more-straightforwardly written as the equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">checkcast</span><span class="p">(</span><span class="n">typx</span><span class="p">:</span> <span class="n">TypeExpr</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</pre></div>
</div>
</section>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="type-c" role="doc-footnote">
<dt class="label" id="type-c">[<a href="#id1">1</a>]</dt>
<dd><a class="pep reference internal" href="../pep-0484/#the-type-of-class-objects" title="PEP 484 – Type Hints § The type of class objects">Type[C] spells a class object</a></aside>
<aside class="footnote brackets" id="typeispep" role="doc-footnote">
<dt class="label" id="typeispep">[<a href="#id3">2</a>]</dt>
<dd><a class="pep reference internal" href="../pep-0742/" title="PEP 742 – Narrowing types with TypeIs">TypeIs[T] is similar to bool</a></aside>
<aside class="footnote brackets" id="dataclassinitvar" role="doc-footnote">
<dt class="label" id="dataclassinitvar">[<a href="#id4">3</a>]</dt>
<dd><code class="docutils literal notranslate"><span class="pre">dataclass.make_dataclass</span></code> accepts <code class="docutils literal notranslate"><span class="pre">InitVar[...]</span></code> as a special case
in addition to type expressions. Therefore it may unfortunately be necessary
to continue annotating its <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter as <code class="docutils literal notranslate"><span class="pre">object</span></code> rather
than <code class="docutils literal notranslate"><span class="pre">TypeExpr</span></code>.</aside>
<aside class="footnote brackets" id="forward-ref-normalization" role="doc-footnote">
<dt class="label" id="forward-ref-normalization">[<a href="#id6">4</a>]</dt>
<dd>Special forms normalize string arguments to <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> instances
at runtime using internal helper functions in the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module.
Runtime type checkers may wish to implement similar functions when
working with string-based forward references.</aside>
<aside class="footnote brackets" id="strann-less-common" role="doc-footnote">
<dt class="label" id="strann-less-common">[<a href="#id8">5</a>]</dt>
<dd>Stringified type annotations are expected to become less common
starting in Python 3.14 when <a class="pep reference internal" href="../pep-0649/" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors">deferred annotations</a>
become available. However there is a large amount of existing code from
earlier Python versions relying on stringified type annotations that will
still need to be supported for several years.</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0747.rst">https://github.com/python/peps/blob/main/peps/pep-0747.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0747.rst">2024-07-09 02:17:30 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#why-cant-type-be-used">Why can’t <code class="docutils literal notranslate"><span class="pre">type[]</span></code> be used?</a></li>
<li><a class="reference internal" href="#common-kinds-of-functions-that-would-benefit-from-typeexpr">Common kinds of functions that would benefit from TypeExpr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#using-typeexprs">Using TypeExprs</a></li>
<li><a class="reference internal" href="#typeexpr-values">TypeExpr Values</a><ul>
<li><a class="reference internal" href="#explicit-typeexpr-values">Explicit TypeExpr Values</a></li>
<li><a class="reference internal" href="#implicit-typeexpr-values">Implicit TypeExpr Values</a></li>
<li><a class="reference internal" href="#literal-typeexprs">Literal[] TypeExprs</a></li>
<li><a class="reference internal" href="#static-vs-runtime-representations-of-typeexprs">Static vs. Runtime Representations of TypeExprs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#subtyping">Subtyping</a><ul>
<li><a class="reference internal" href="#relationship-with-type">Relationship with type</a></li>
<li><a class="reference internal" href="#relationship-with-uniontype">Relationship with UnionType</a></li>
<li><a class="reference internal" href="#relationship-with-object">Relationship with object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interactions-with-isinstance-and-issubclass">Interactions with isinstance() and issubclass()</a></li>
<li><a class="reference internal" href="#affected-signatures-in-the-standard-library">Affected signatures in the standard library</a><ul>
<li><a class="reference internal" href="#changed-signatures">Changed signatures</a></li>
<li><a class="reference internal" href="#unchanged-signatures">Unchanged signatures</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#advanced-examples">Advanced Examples</a><ul>
<li><a class="reference internal" href="#introspecting-typeexpr-values">Introspecting TypeExpr Values</a></li>
<li><a class="reference internal" href="#combining-with-a-type-variable">Combining with a type variable</a></li>
<li><a class="reference internal" href="#combining-with-type">Combining with type[]</a></li>
<li><a class="reference internal" href="#combining-with-typeis-and-typeguard">Combining with TypeIs[] and TypeGuard[]</a></li>
<li><a class="reference internal" href="#challenges-when-accepting-all-typeexprs">Challenges When Accepting All TypeExprs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#widen-type-c-to-support-all-type-expressions">Widen type[C] to support all type expressions</a></li>
<li><a class="reference internal" href="#accept-arbitrary-annotation-expressions">Accept arbitrary annotation expressions</a></li>
<li><a class="reference internal" href="#accept-only-universal-type-expressions">Accept only universal type expressions</a></li>
<li><a class="reference internal" href="#support-pattern-matching-on-type-expressions">Support pattern matching on type expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0747.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
</body>
</html>